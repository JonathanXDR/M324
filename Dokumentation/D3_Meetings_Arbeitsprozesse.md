# [Meetings / Arbeitsprozesse](https://gitlab.com/ch-tbz-it/Stud/m324/-/blob/main/Projekt/D3_Meetings_Prozesse.md)

## Meetings

### Rollen

| Rolle             | Beschreibung                                                                                                                                                                                                          | Name                                                |
| ----------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------- |
| **Scrum Master**  | Verantwortlich für die Implementierung und Einhaltung des Scrum-Prozesses. Unterstützt das Team dabei, effektiv zu arbeiten, beseitigt Hindernisse und stellt sicher, dass Scrum-Praktiken korrekt angewendet werden. | Zakria Samma                                        |
| **Product Owner** | Vertritt die Interessen der Stakeholder und Endbenutzer. Verantwortlich für die Definition und Priorisierung der Produktanforderungen im Product Backlog, um wertvolle Ergebnisse sicherzustellen.                    | Zakria Samma                                        |
| **Stakeholder**   | Person oder Gruppe mit Interesse am Projekt, die Anforderungen, Feedback und wichtige Entscheidungen liefert.                                                                                                         | Thanam Pangri                                       |
| **Developer**     | Teammitglieder, die Anforderungen umsetzen, testen und funktionierende Produktinkremente gemäss den Vorgaben des Product Owners liefern.                                                                              | Jonathan Russ, Pascal Rieder, Jon Landa, Kalel Jong |

### Meeting-Typen

#### Daily Meetings

- Finden wöchentlich mitten im Sprint statt.
- Themen:
  - Besprechung der am Vortag gelösten Aufgaben (vom Stakeholder kontrolliert und reflektiert).
  - Planung der täglichen Aufgaben und User Stories.
  - Kurzes Update zur gestrigen Retrospektive.

#### Retrospective (KVP)

- Wöchentliche Meetings am Ende des Sprints (Donnerstags ca. 16:15 - 16:30).
- Themen:
  - Reflexion der Woche.
  - Verbesserungsvorschläge für die nächste Woche.

### Meeting-Protokolle

#### 21.11.2024

**Daily Meeting:**

- User Stories für alle Aufgaben erstellen.
- Subtasks zu User Stories erfassen und zuordnen.
- Planung/Meeting-Struktur definieren.
- KVP für den Unterrichtstag planen.

---

#### 05.12.2024

**Daily Meeting:**

- T3 schätzen und erledigen

- **Positives:**
  - T1 gut abgeschlossen.
  - Bereits mit T4 begonnen
- **Verbesserungen:**
  - Link zu Theorieinhalte fehlen
  - T2 Antworten überarbeiten

---

#### 12.12.2024

**Daily Meeting:**

- T4 fertigstellen
- T5 schätzen und beginnen

**Retrospective:**

- **Positives:**
  - Konstruktive Kritik am Stakeholder führte zu einer Notenverbesserung um 0.2.
  - D2 wurde schneller als geplant abgeschlossen; Aufgaben-Grösse wurde falsch eingeschätzt.
- **Verbesserungen:**
  - Conventional Commits einführen, um die zugehörigen User Stories besser zu identifizieren.
  - Neue User Story IDs (z. B. `T5-1`).

---

#### 19.12.2024

**Daily Meeting:**

- Definition von Conventional Commits.
- T5 fertigstellen.
- D2 anpassen.
- Lernjournal (D5) regelmässig erfassen und pushen.
- User Stories erstellen.
- Anpassung der User Story IDs (z. B. `User Story: Band erfassen`).

**Retrospective:**

- **Positives:**
  - Erstes Review erfolgreich durchgeführt.
  - Viele User Stories und Tasks auf dem Kanban erstellt.
  - Fokus auf Programmieren bei T5.
- **Verbesserungen:**
  - Mehr Zeit für Conventional Commits.
  - Neue User Story IDs definieren.
  - Tasks für Rollenberechtigungen erstellen.
  - User Stories und Tasks für P3, P4, Z3 erstellen.
  - Ablenkungen im Team reduzieren.

---

#### 09.01.2025

**Daily Meeting:**

- Alle verbleibenden Tasks von P2 schätzen.
- Beginn mit P2.

**Retrospective:**

- **Positives:**
  - Alles nötige für P2 vorbereitet (Schätzung, Tasks usw.).
- **Verbesserungen:**
- Setup vom Projekt dauerte länger als geplant.

---

#### 16.01.2025

**Daily Meeting:**

- Weiterarbeit an P2 (kontinuierliches Arbeiten).

**Retrospective:**

- **Positives:**
  - Branching-Strategie eingehalten.
  - Commit-Strategie eingehalten.
  - T5-Review verlief gut.
  - Produktives Arbeiten.
- **Verbesserungen:**
  - Scrum Master war abwesend; Diskussion über Wechsel des Scrum Masters.

---

#### 23.01.2025

**Daily Meeting:**

- Weiterarbeit an P2 (kontinuierliches Arbeiten).
- Beginn mit P3

**Retrospective:**

- **Positives:**
  - Produktives Arbeiten.
- **Verbesserungen:**
  - D3 Meeting Doku nicht komplett, fehlende Inhalte ergänzen.

# Meetings und Arbeitsprozesse

## Scrum-Prozess

### Rollen und Verantwortlichkeiten

In unserem Projektteam haben wir verschiedene Scrum-Rollen definiert, die jeweils mit spezifischen Verantwortlichkeiten verbunden sind. Als Scrum Master fungiert Zakria Samma, der für die erfolgreiche Implementierung und Aufrechterhaltung der Scrum-Praktiken verantwortlich ist. In dieser Rolle unterstützt er das Team dabei, effizient zu arbeiten, beseitigt auftretende Hindernisse und stellt sicher, dass die Scrum-Prinzipien korrekt angewendet werden.

Zakria Samma übernimmt zusätzlich die Rolle des Product Owners. In dieser Position vertritt er die Interessen der Stakeholder und Endnutzer. Er ist verantwortlich für die Definition und Priorisierung der Produktanforderungen im Product Backlog, um sicherzustellen, dass wertvolle Ergebnisse erzielt werden.

Als wichtiger Stakeholder bringt Thanam Pangri seine Expertise ein und liefert wesentliche Anforderungen, Feedback und Entscheidungen für das Projekt. Das Entwicklungsteam besteht aus Jonathan Russ, Pascal Rieder, Jon Landa und Kalel Jong. Sie setzen die Anforderungen um, führen Tests durch und liefern funktionale Produktinkremente gemäss den Vorgaben des Product Owners.

### Sprint-Planung und Daily Meetings

Unser Entwicklungsprozess basiert auf wöchentlichen Sprints, die einen überschaubaren Zeitrahmen für die Umsetzung definierter Ziele bieten. Die Daily Meetings finden einmal pro Woche in der Mitte des Sprints statt. In diesen Meetings besprechen wir drei wesentliche Aspekte: Zunächst erfolgt eine Überprüfung der am Vortag abgeschlossenen Aufgaben, die vom Stakeholder validiert werden. Anschliessend planen wir die anstehenden Aufgaben und User Stories für den aktuellen Tag. Abschliessend werfen wir einen kurzen Blick auf die Erkenntnisse aus der letzten Retrospektive, um sicherzustellen, dass wir die vereinbarten Verbesserungsmassnahmen umsetzen.

### Sprint-Retrospektive

Die Sprint-Retrospektive ist ein wesentlicher Bestandteil unseres kontinuierlichen Verbesserungsprozesses. Sie findet wöchentlich am Ende des Sprints, üblicherweise donnerstags von 16:15 bis 16:30 Uhr, statt. In dieser Session reflektiert das Team gemeinsam über die vergangene Woche und identifiziert Verbesserungspotenziale für den nächsten Sprint. Die gesammelten Erkenntnisse werden dokumentiert und in konkrete Massnahmen umgesetzt. Durch diesen regelmässigen Prozess stellen wir sicher, dass wir uns als Team kontinuierlich weiterentwickeln und unsere Arbeitsweise optimieren.

## Aufgabenverwaltung

### GitHub Projects und Kanban-System

Für die Organisation und Verwaltung unserer Aufgaben nutzen wir GitHub Projects mit einem Kanban-Board. Dieses visuelle System ermöglicht es uns, den Fortschritt unserer Arbeit transparent darzustellen und effektiv zu verwalten. Unser Board ist in mehrere Spalten unterteilt, die den Workflow abbilden:

1. **Backlog**

   - Noch nicht gestartete Items
   - Grössere Epics/User Stories oder Ideen, die später umgesetzt werden

2. **Ready**

   - Aufgaben, die zur Bearbeitung freigegeben sind
   - Klare Anforderung und geschätzter Umfang

3. **In Progress**

   - Aufgaben, an denen gerade gearbeitet wird
   - Typischerweise wird hier auch ein PR eröffnet

4. **Review**

   - Fertig implementierte Items, die auf Code-Review warten
   - Möglicherweise offener Pull Request

5. **Rework**

   - Items, die nach dem Review überarbeitet werden müssen
   - Fehler, Verbesserungen oder zusätzliche Anforderungen

6. **Done**
   - Abgeschlossene und abgenommene Aufgaben
   - Code ist gemergt und Tests sind erfolgreich

### Strukturierung der Issues

Die Verwaltung unserer Aufgaben erfolgt durch ein klar definiertes System von Issues in GitHub. Wir unterscheiden dabei zwischen verschiedenen Hierarchieebenen, die durch spezifische Prefixe gekennzeichnet werden. Epics stellen dabei die oberste Ebene dar und werden mit dem Prefix `Epic:` versehen. Sie repräsentieren grössere Initiativen oder Projektphasen, wie beispielsweise `Epic: P2`. User Stories, gekennzeichnet durch das Prefix `User Story:`, beschreiben konkrete Anforderungen aus Anwendersicht. Ein Beispiel hierfür ist `User Story: Band erfassen`, das die Funktionalität zur Erfassung einer neuen Band im System beschreibt. Die kleinsten Einheiten sind Tasks, markiert mit dem Prefix `Task:`, die spezifische Arbeitsaufgaben darstellen, wie etwa "Task: Fehlervalidierung beim erfassen einer Band".

Für die Aufwandsschätzung verwenden wir ein T-Shirt-Grössensystem, das uns hilft, den Umfang von Aufgaben besser einzuordnen. Die Grössen reichen von XS für sehr kleine Aufgaben (1-2 Stunden) bis hin zu 3XL für komplexe Initiativen, die eine weitere Unterteilung erfordern. Diese Schätzungen helfen uns bei der Sprint-Planung und der gleichmässigen Verteilung der Arbeitslast. Anbei eine kurze Übersicht über die Bedeutung der T-Shirt-Grössen:

| Groesse | Bedeutung                                            |
| ------- | ---------------------------------------------------- |
| S       | kleine Aufgabe (z. B. 0.5 – 1 Tag)                   |
| M       | mittlere Aufgabe (ca. 1 – 2 Tage)                    |
| L       | grosse Aufgabe (z. B. 2 – 3 Tage)                    |
| XL      | sehr grosse Aufgabe (3 – 4 Tage)                     |
| 2XL     | sehr umfangreich, ggf. Split erforderlich            |
| 3XL     | extrem gross, sollte in mehrere Tasks zerlegt werden |

---

## Code-Qualität und Standards

### Git-Workflow und Branching-Strategie

Unser Git-Workflow basiert auf einer durchdachten Branching-Strategie, die sowohl die Entwicklung neuer Features als auch die Wartung des Produktivsystems unterstützt. Der main-Branch repräsentiert dabei stets den produktiven Stand der Anwendung. Parallel dazu existiert der develop-Branch als Integrationsumgebung für neue Entwicklungen.

Für die Entwicklung neuer Features erstellen wir feature-Branches, die vom develop-Branch abzweigen. Bugfixes vor einem Release werden in bugfix-Branches bearbeitet. Für die Vorbereitung von Releases nutzen wir release-Branches, während kritische Fehlerbehebungen im Produktivsystem über hotfix-Branches erfolgen.

### Commit-Standards und Qualitätssicherung

Wir verwenden [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) als Standard für unsere Commit-Messages. Diese Konvention ermöglicht eine klare und einheitliche Dokumentation der Änderungen im Code. Die wichtigsten Prefixe sind dabei:

- feat: für neue Funktionalitäten
- fix: für Fehlerbehebungen
- docs: für Dokumentationsänderungen
- style: für Code-Style-Anpassungen
- refactor: für Code-Überarbeitungen
- test: für Test-bezogene Änderungen
- chore: für Wartungsarbeiten

Die Qualitätssicherung unseres Codes wird durch verschiedene automatisierte Prozesse unterstützt. Mit Hilfe von [Husky](https://github.com/typicode/husky) und [lint-staged](https://github.com/lint-staged/lint-staged) haben wir Pre-Commit-Hooks eingerichtet, die vor jedem Commit eine Reihe von Überprüfungen durchführen. Dazu gehören das Linting mit ESLint, die Formatierung mit Prettier und die Typenprüfung mit TypeScript. Zusätzlich wird die Einhaltung unserer Commit-Message-Konventionen überprüft.

### Code-Review-Prozess

Ein wesentlicher Bestandteil unserer Qualitätssicherung ist der Code-Review-Prozess. Jede Änderung muss von mindestens zwei anderen Teammitgliedern überprüft und genehmigt werden, bevor sie in den develop-Branch integriert werden kann. Bei den Reviews achten wir besonders auf die Einhaltung unserer Coding-Standards, eine ausreichende Testabdeckung, vollständige Dokumentation und Performance-Aspekte.

### Teststrategie

Unsere Teststrategie umfasst mehrere Ebenen, um die Qualität unserer Anwendung sicherzustellen. Auf der untersten Ebene führen wir Unit-Tests durch, die einzelne Komponenten und Funktionen isoliert prüfen. Darüber hinaus implementieren wir Integrationstests, die das Zusammenspiel verschiedener Komponenten, insbesondere unserer API-Endpunkte, verifizieren. System-Tests validieren schliesslich die End-to-End-Funktionalität unserer Workflows.

## Datenbank-Management

### Architektur und Werkzeuge

Unsere Datenbankarchitektur basiert auf MariaDB als primärem Datenbanksystem. Für die Interaktion mit der Datenbank nutzen wir Prisma als Object-Relational Mapping (ORM) Tool, das uns eine typsichere und effiziente Datenbankanbindung ermöglicht. In der lokalen Entwicklungsumgebung setzen wir auf Docker für die Containerisierung der Datenbank, während wir in der Produktivumgebung Amazon RDS nutzen.

### Datenbank-Prozesse

Die Verwaltung unseres Datenbankschemas erfolgt über Prisma Migrations. Diese Migrations dokumentieren alle Schemaänderungen und ermöglichen es uns, die Datenbankstruktur konsistent und nachvollziehbar weiterzuentwickeln. Die Migrationsdateien werden im Verzeichnis `/prisma/migrations` gespeichert und können über den Befehl `prisma migrate` ausgeführt werden.

Nach der Ausführung von Migrationen wird automatisch ein Seeding-Prozess angestossen, der die Datenbank mit initialen Testdaten befüllt. Die entsprechenden Seed-Skripte befinden sich in der Datei `/prisma/seed.ts` und können über das npm-Script `database:setup` ausgeführt werden.

### Backup-Strategie

In der Produktivumgebung nutzen wir die automatisierten Backup-Funktionen von Amazon RDS, um regelmässige Sicherungen unserer Datenbank zu erstellen. In der lokalen Entwicklungsumgebung werden die Daten über Docker-Volumes persistent gespeichert, wodurch sie auch nach einem Neustart des Containers erhalten bleiben.

## API-Standards und Dokumentation

Unsere API folgt den Prinzipien des REST-Architekturstils. Die Routen sind ressourcenbasiert gestaltet und nutzen die Standard-HTTP-Methoden GET, POST, PUT und DELETE. Für die Dokumentation der API pflegen wir eine Postman Collection, die alle verfügbaren Endpunkte, deren Parameter und erwartete Antwortformate beschreibt. Diese Dokumentation enthält auch Beispiele und Testfälle, die die Verwendung der API demonstrieren.

## Sicherheit und Konfiguration

### Umgebungsvariablen und Secrets

Die Verwaltung sensibler Konfigurationsdaten erfolgt über Umgebungsvariablen. In der lokalen Entwicklung nutzen wir eine `.env`-Datei für grundlegende Konfigurationen und eine `.env.local`-Datei für individuelle Überschreibungen. Produktive Secrets werden sicher in den GitHub Secrets gespeichert und sind nur im Rahmen der CI/CD-Pipeline verfügbar.

- **.env** enthält sensible Variablen wie `DATABASE_URL`, `APP_PORT` etc.
- **.env** steht in `.gitignore`, damit keine Passwörter oder Tokens ins Repo gelangen.
- In Produktionssystemen verwenden wir **GitHub Actions Secrets** oder **Vercel Environment Variables**.

### Beispiele

```bash
# .env (lokal)
APP_NAME="M324 Music Platform"
APP_PORT=3000
DATABASE_URL="mysql://root:root1234@localhost:3306/m324_music_platform"
```

### Continuous Integration und Delivery

Unsere CI/CD-Pipeline automatisiert den gesamten Prozess von der Entwicklung bis zur Bereitstellung. Die Continuous Integration umfasst automatisierte Tests, Code-Qualitätsprüfungen und Build-Verifikationen. Das Continuous Delivery erfolgt über Vercel, wo unsere Anwendung automatisch deployed wird. Dabei werden umgebungsspezifische Konfigurationen berücksichtigt und Rollback-Möglichkeiten vorgehalten.

Die Pipeline enthält auch ein umfangreiches Monitoring- und Logging-System, das uns hilft, die Performance und Stabilität unserer Anwendung kontinuierlich zu überwachen und bei Bedarf schnell reagieren zu können.
